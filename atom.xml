<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeetCode</title>
  
  <subtitle>刷题心得与笔记</subtitle>
  <link href="/leetcode/atom.xml" rel="self"/>
  
  <link href="https://songouyang.github.io/leetcode/"/>
  <updated>2019-03-15T06:44:54.942Z</updated>
  <id>https://songouyang.github.io/leetcode/</id>
  
  <author>
    <name>欧阳松</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>350. Intersection of Two Arrays II</title>
    <link href="https://songouyang.github.io/leetcode/intersection-of-two-arrays-ii/"/>
    <id>https://songouyang.github.io/leetcode/intersection-of-two-arrays-ii/</id>
    <published>2019-03-15T14:26:24.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>同样是两个数组求公共交集，但是这里要求交集中可以存在相同的数字。</p><a id="more"></a><p>使用 map 用来计数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; num1: nums1)&#123;</span><br><span class="line">            umap[num1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(umap[num2]-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同样是两个数组求公共交集，但是这里要求交集中可以存在相同的数字。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>349. Intersection of Two Arrays</title>
    <link href="https://songouyang.github.io/leetcode/intersection-of-two-arrays/"/>
    <id>https://songouyang.github.io/leetcode/intersection-of-two-arrays/</id>
    <published>2019-03-15T14:24:57.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>两个数组的交集。</p><a id="more"></a><p>用 set 进行去重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp; num2: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.erase(num2)) result.push_back(num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个数组的交集。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>347. Top K Frequent Elements</title>
    <link href="https://songouyang.github.io/leetcode/top-k-frequent-elements/"/>
    <id>https://songouyang.github.io/leetcode/top-k-frequent-elements/</id>
    <published>2019-03-15T14:23:14.000Z</published>
    <updated>2019-03-15T06:44:54.946Z</updated>
    
    <content type="html"><![CDATA[<p>找出数组中出现次数前 k 的元素。</p><a id="more"></a><p>用 map 记录数字出现的字数，用优先队列对次数进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">            umap[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = umap.begin(); it != umap.end(); ++it) &#123;</span><br><span class="line">            pq.push(make_pair(it-&gt;second, it-&gt;first));</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; umap.size() - k) &#123;</span><br><span class="line">                result.push_back(pq.top().second);</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找出数组中出现次数前 k 的元素。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>345. Reverse Vowels of a String</title>
    <link href="https://songouyang.github.io/leetcode/reverse-vowels-of-a-string/"/>
    <id>https://songouyang.github.io/leetcode/reverse-vowels-of-a-string/</id>
    <published>2019-03-15T13:55:10.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>翻转字符串，只翻转元音字母。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseVowels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a &lt; b &amp;&amp; !helper(s[a])) &#123;</span><br><span class="line">                ++a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (a &lt; b &amp;&amp; !helper(s[b])) &#123;</span><br><span class="line">                --b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">                swap(s[a++], s[b--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">'a'</span> || c == <span class="string">'e'</span> || c == <span class="string">'i'</span> || c == <span class="string">'o'</span> || c == <span class="string">'u'</span> || c == <span class="string">'A'</span> || c == <span class="string">'E'</span> || c == <span class="string">'I'</span> ||</span><br><span class="line">               c == <span class="string">'O'</span> || c == <span class="string">'U'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻转字符串，只翻转元音字母。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>344. Reverse String</title>
    <link href="https://songouyang.github.io/leetcode/reverse-string/"/>
    <id>https://songouyang.github.io/leetcode/reverse-string/</id>
    <published>2019-03-15T13:53:08.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>翻转字符串。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">            s[i] = s[n - <span class="number">1</span> - i];</span><br><span class="line">            s[n - <span class="number">1</span> - i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻转字符串。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>343. Integer Break</title>
    <link href="https://songouyang.github.io/leetcode/integer-break/"/>
    <id>https://songouyang.github.io/leetcode/integer-break/</id>
    <published>2019-03-15T13:48:30.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数 n，将 n 分成至少两个整数，使得分成后的整数之积最大。</p><a id="more"></a><p>只要 n 大于 4，它可以对半分，然后乘积会更大。当它等于 4，那么拆不拆都是一样。小于 4 就直接特例判断。<br>那么一直对半分要么是回落到 1、2、3 三者之一。优先使用 3，因为通过 6 的例子，知道 3 会使得结果更大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            result *= <span class="number">3</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个整数 n，将 n 分成至少两个整数，使得分成后的整数之积最大。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>342. Power of Four</title>
    <link href="https://songouyang.github.io/leetcode/power-of-four/"/>
    <id>https://songouyang.github.io/leetcode/power-of-four/</id>
    <published>2019-03-15T13:16:17.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个数字是否是 4 的指数次方。</p><a id="more"></a><p>num 需要大于 0，并且用二进制表示只有 1 个 1，那么就只剩下 2 的指数次方和 4 的指数次方。<br>4^n % 3 等于 (4%3)^n % 3 等于 1。而假设 n 是奇数，那么 2^n 等于 2^(n-1) * 2，前者的余数为 1，后者的余数为 2。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt; <span class="number">0</span>) &amp;&amp; ((num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>) &amp;&amp; ((num - <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个数字是否是 4 的指数次方。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>341. Flatten Nested List Iterator</title>
    <link href="https://songouyang.github.io/leetcode/flatten-nested-list-iterator/"/>
    <id>https://songouyang.github.io/leetcode/flatten-nested-list-iterator/</id>
    <published>2019-03-15T13:07:49.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>将一个多层数组打平，并得到迭代器。</p><a id="more"></a><p>一种办法就是在算 next 的时候动态去获取下一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            nodes.push(nestedList[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = nodes.top().getInteger();</span><br><span class="line">        nodes.pop();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!nodes.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> curr = nodes.top();</span><br><span class="line">            <span class="keyword">if</span> (curr.isInteger()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            nodes.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = curr.getList().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                nodes.push(curr.getList()[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;NestedInteger&gt; nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有个办法就是初始化的时候就递归转化成一个数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Fill</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i : l) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.isInteger()) &#123;</span><br><span class="line">                list_.push_back(i.getInteger());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Fill(i.getList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line">        Fill(nestedList);</span><br><span class="line">        idx_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list_[idx_++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx_ != list_.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; list_;</span><br><span class="line">    <span class="keyword">int</span> idx_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个多层数组打平，并得到迭代器。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>338. Counting Bits</title>
    <link href="https://songouyang.github.io/leetcode/counting-bits/"/>
    <id>https://songouyang.github.io/leetcode/counting-bits/</id>
    <published>2019-03-15T12:45:45.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个数字 n，求从 0 到 n 所有数字中用二进制表示的时候有多少个 1。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(num+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">            result[i] = result[i&amp;(i<span class="number">-1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一个数字 n，求从 0 到 n 所有数字中用二进制表示的时候有多少个 1。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>337. House Robber III</title>
    <link href="https://songouyang.github.io/leetcode/house-robber-iii/"/>
    <id>https://songouyang.github.io/leetcode/house-robber-iii/</id>
    <published>2019-03-15T12:30:59.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>相临的两个树节点不能被连续抢劫。</p><a id="more"></a><p>本节点加上左子树和右子树的子节点，左子树和右子树的和，取两者的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">return</span> helper(root, umap);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode * root, <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&amp;umap)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(umap.count(root)) <span class="keyword">return</span> umap[root];</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            val += helper(root-&gt;left-&gt;left, umap) + helper(root-&gt;left-&gt;right, umap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            val += helper(root-&gt;right-&gt;left, umap) + helper(root-&gt;right-&gt;right, umap);;</span><br><span class="line">        &#125;</span><br><span class="line">        val = max(val + root-&gt;val, helper(root-&gt;left, umap)+helper(root-&gt;right, umap));</span><br><span class="line">        umap[root] = val;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相临的两个树节点不能被连续抢劫。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>336. Palindrome Pairs</title>
    <link href="https://songouyang.github.io/leetcode/palindrome-pairs/"/>
    <id>https://songouyang.github.io/leetcode/palindrome-pairs/</id>
    <published>2019-03-15T11:27:55.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>找出所有俩俩组成回文的字符串。</p><a id="more"></a><p>这个题目花了很长时间理解。</p><p>首先是采用 Trie 树的方法，把单词反过来建树，然后搜索。这个解法不能通过，因为会 <code>Memory Limit Exceeded</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode *&gt; children;</span><br><span class="line"></span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">        idx = <span class="number">-1</span>;</span><br><span class="line">        children = <span class="built_in">vector</span>&lt;TrieNode *&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; palindromePairs(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            add(words[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            search(words[i], i, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> word, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="keyword">int</span>) word.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(word, <span class="number">0</span>, j)) node-&gt;indices.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (!node-&gt;children[word[j] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                node-&gt;children[word[j] - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[word[j] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;idx = i;</span><br><span class="line">        node-&gt;indices.push_back(i);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;result)</span> </span>&#123;</span><br><span class="line">        TrieNode *node = root;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) word.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; node; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;idx &gt;= <span class="number">0</span> &amp;&amp; isValid(word, j, n - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.push_back(&#123;i, node-&gt;idx&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[word[j] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it: node-&gt;indices) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it != i) &#123;</span><br><span class="line">                    result.push_back(&#123;i, it&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> word, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word[i++] != word[j--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后是采用 map 和 set 来实现的。用 map 记录字符串到下标的映射。用 set 记录所有单词的长度。然后将单词反转，判断是否存在。接下来从比该单词更短的单词中找到，它要求多余出来的那部分已经是个回文了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; palindromePairs(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            umap[words[i]] = i;</span><br><span class="line">            s.insert(words[i].size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> tmp = words[i];</span><br><span class="line">            <span class="keyword">int</span> len = (<span class="keyword">int</span>) tmp.size();</span><br><span class="line">            reverse(tmp.begin(), tmp.end());</span><br><span class="line">            <span class="keyword">if</span> (umap.count(tmp) &amp;&amp; umap[tmp] != i) &#123;</span><br><span class="line">                result.push_back(&#123;i, umap[tmp]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> a = s.find(len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != a; ++it) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = *it;</span><br><span class="line">                <span class="keyword">if</span> (isValid(tmp, <span class="number">0</span>, len - d - <span class="number">1</span>) &amp;&amp; umap.count(tmp.substr(len - d))) &#123;</span><br><span class="line">                    result.push_back(&#123;i, umap[tmp.substr(len - d)]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isValid(tmp, d, len - <span class="number">1</span>) &amp;&amp; umap.count(tmp.substr(<span class="number">0</span>, d))) &#123;</span><br><span class="line">                    result.push_back(&#123;umap[tmp.substr(<span class="number">0</span>, d)], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i++] != s[j--]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找出所有俩俩组成回文的字符串。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>335. Self Crossing</title>
    <link href="https://songouyang.github.io/leetcode/self-crossing/"/>
    <id>https://songouyang.github.io/leetcode/self-crossing/</id>
    <published>2019-03-13T13:21:24.000Z</published>
    <updated>2019-03-15T06:44:54.946Z</updated>
    
    <content type="html"><![CDATA[<p>判断走位会不会自己相交。</p><a id="more"></a><p>相交的情况一共分成 3 种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    x(1)</span><br><span class="line">    ┌───┐</span><br><span class="line">x(2)│   │x(0)</span><br><span class="line">    └───┼──&gt;</span><br><span class="line">    x(3)│</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      x(1)</span><br><span class="line">    ┌──────┐</span><br><span class="line">    │      │x(0)</span><br><span class="line">x(2)│      ^</span><br><span class="line">    │      │x(4)</span><br><span class="line">    └──────│</span><br><span class="line">      x(3)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      x(1)</span><br><span class="line">    ┌──────┐</span><br><span class="line">    │      │x(0)</span><br><span class="line">x(2)│     &lt;│────│</span><br><span class="line">    │       x(5)│x(4)</span><br><span class="line">    └───────────│</span><br><span class="line">        x(3)</span><br></pre></td></tr></table></figure><p>对应的代码的三种判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSelfCrossing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; x.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] &gt;= x[i - <span class="number">2</span>] &amp;&amp; x[i - <span class="number">1</span>] &gt;= x[i - <span class="number">3</span>])<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">4</span> &amp;&amp; x[i - <span class="number">1</span>] == x[i - <span class="number">3</span>] &amp;&amp; x[i] &gt;= x[i - <span class="number">2</span>] - x[i - <span class="number">4</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">5</span> &amp;&amp; x[i - <span class="number">2</span>] &gt;= x[i - <span class="number">4</span>] &amp;&amp; x[i - <span class="number">1</span>] &gt;= x[i - <span class="number">3</span>] - x[i - <span class="number">5</span>] &amp;&amp; x[i] &gt;= x[i - <span class="number">2</span>] - x[i - <span class="number">4</span>] &amp;&amp;</span><br><span class="line">                x[i - <span class="number">3</span>] &gt;= x[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断走位会不会自己相交。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>334. Increasing Triplet Subsequence</title>
    <link href="https://songouyang.github.io/leetcode/increasing-triplet-subsequence/"/>
    <id>https://songouyang.github.io/leetcode/increasing-triplet-subsequence/</id>
    <published>2019-03-08T15:34:18.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个数组中是否存在三个递增的序列，可以不连续。</p><a id="more"></a><p>用 a1 和 a2 来记录目前遇到的最小的和倒数第二小的，如果遇到第三个，那么就说明存在了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a1 = INT_MAX, a2 = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= a1) &#123;</span><br><span class="line">                a1 = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= a2) &#123;</span><br><span class="line">                a2 = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个数组中是否存在三个递增的序列，可以不连续。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>332. Reconstruct Itinerary</title>
    <link href="https://songouyang.github.io/leetcode/reconstruct-itinerary/"/>
    <id>https://songouyang.github.io/leetcode/reconstruct-itinerary/</id>
    <published>2019-03-08T11:12:50.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>根据机票重构出飞行路线。</p><a id="more"></a><p>遇到可行的几种方案，需要按照字典排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findItinerary(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; tickets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ticket: tickets) &#123;</span><br><span class="line">            routes[ticket.first].insert(ticket.second);</span><br><span class="line">        &#125;</span><br><span class="line">        helper(<span class="string">"JFK"</span>);</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt;&gt; routes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (routes[start].size()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> tmp = *routes[start].begin();</span><br><span class="line">            routes[start].erase(routes[start].begin());</span><br><span class="line">            helper(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        result.push_back(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据机票重构出飞行路线。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>331. Verify Preorder Serialization of a Binary Tree</title>
    <link href="https://songouyang.github.io/leetcode/verify-preorder-serialization-of-a-binary-tree/"/>
    <id>https://songouyang.github.io/leetcode/verify-preorder-serialization-of-a-binary-tree/</id>
    <published>2019-03-07T17:15:21.000Z</published>
    <updated>2019-03-15T06:44:54.946Z</updated>
    
    <content type="html"><![CDATA[<p>验证一个字符串是不是可以反序列化成一个二叉树。</p><a id="more"></a><p>能够反序列化的字符串应该满足以下的条件：</p><ol><li>最后必须是 <code>#</code></li><li>从左到右的过程中，保持 <code>#</code> 的数量更多，可以保持相等。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSerialization</span><span class="params">(<span class="built_in">string</span> preorder)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> buf = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (getline(in, buf, <span class="string">','</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (buf == <span class="string">"#"</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--count == <span class="number">0</span>) flag = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;验证一个字符串是不是可以反序列化成一个二叉树。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>330. Patching Array</title>
    <link href="https://songouyang.github.io/leetcode/patching-array/"/>
    <id>https://songouyang.github.io/leetcode/patching-array/</id>
    <published>2019-03-07T15:47:20.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>题目提供了一个数组，需要你补充一些数字，使得这些元素可以拼接 1 到 n 的值。</p><a id="more"></a><p>首先从 1 开始补。如果已经补充到 n1 了，如果下一个数组中的数字大于 n1 + 1，那么就需要补充 n1 + 1 了。如果小于的话，那就利用本有的数字 m1，那么现在最大的范围就是 n1+m1 了。然后就是下一个值就是 n1+m1+1 了，以此类推。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPatches</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.size() &amp;&amp; nums[i] &lt;= num + <span class="number">1</span>) &#123;</span><br><span class="line">                num += nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num += num + <span class="number">1</span>;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目提供了一个数组，需要你补充一些数字，使得这些元素可以拼接 1 到 n 的值。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>329. Longest Increasing Path in a Matrix</title>
    <link href="https://songouyang.github.io/leetcode/longest-increasing-path-in-a-matrix/"/>
    <id>https://songouyang.github.io/leetcode/longest-increasing-path-in-a-matrix/</id>
    <published>2019-03-07T15:45:14.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>寻找二为矩阵中最长的递增路径。</p><a id="more"></a><p>这个和之前的在二为矩阵中找字符串很类似，都是用 DFS，但是这里稍微有点不同的是，为了减少重复计算，降低运算时间，需用用 DP 缓存已经计算过的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? matrix[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = helper(matrix, i, j, m, n, dp);</span><br><span class="line">                result = max(result, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,  <span class="number">0</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j]) <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir: dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i + dir[<span class="number">0</span>], y = j + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">1</span> + helper(matrix, x, y, m, n, dp);</span><br><span class="line">            tmp = max(tmp, len);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;寻找二为矩阵中最长的递增路径。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>328. Odd Even Linked List</title>
    <link href="https://songouyang.github.io/leetcode/odd-even-linked-list/"/>
    <id>https://songouyang.github.io/leetcode/odd-even-linked-list/</id>
    <published>2019-03-07T15:42:51.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>将链表按照奇偶的下标来重新组合。</p><a id="more"></a><p>把奇偶分别接起来，然后把两个链表首尾连起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">oddEvenList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> tmp1 = head, tmp2 = head-&gt;next, tmp3 = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (tmp2 &amp;&amp; tmp2-&gt;next) &#123;</span><br><span class="line">            tmp1-&gt;next = tmp2-&gt;next;</span><br><span class="line">            tmp2-&gt;next = tmp2-&gt;next-&gt;next;</span><br><span class="line">            tmp1 = tmp1-&gt;next;</span><br><span class="line">            tmp2 = tmp2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp1-&gt;next = tmp3;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将链表按照奇偶的下标来重新组合。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>326. Power of Three</title>
    <link href="https://songouyang.github.io/leetcode/power-of-three/"/>
    <id>https://songouyang.github.io/leetcode/power-of-three/</id>
    <published>2019-03-05T16:39:26.000Z</published>
    <updated>2019-03-15T06:44:54.942Z</updated>
    
    <content type="html"><![CDATA[<p>判断一个数字是不是 3 的指数。</p><a id="more"></a><p>用 <code>3^19</code> 来除 <code>n</code>，如果能整除说明满足题意。因为 <code>3^20</code> 已经超过了 <code>int</code> 的范围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;判断一个数字是不是 3 的指数。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>324. Wiggle Sort II</title>
    <link href="https://songouyang.github.io/leetcode/wiggle-sort-ii/"/>
    <id>https://songouyang.github.io/leetcode/wiggle-sort-ii/</id>
    <published>2019-03-05T16:30:55.000Z</published>
    <updated>2019-03-15T06:44:54.946Z</updated>
    
    <content type="html"><![CDATA[<p>摆动排序，就是一会大于，一会小于。</p><a id="more"></a><p>思路很简单，比如说。<br>先把数组排序好，然后从左到右填到奇数的下标，从右到左填到偶数的下标。但是这样的方法是空间复杂度 <code>O(n)</code>，时间复杂度是 <code>O(nlgn)</code>。</p><p>看了网上的分享，知道了下面的解法。首先找到中间大小的数字 <code>mid</code>。然后把小于该数字的数字放到奇数位置，大于的放在偶数位置。注意它的宏，就是一个下标对应函数。<code>nth_element</code> 会把数组排序好，把小于 <code>mid</code> 的数字下标 0、1、2 会对应到 1、3、5 上。而大于的数字下标 3、4、5 会对应到 0、2、4 上了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> index(i) nums[(1 + 2 * i) % (n | 1)]</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), i = <span class="number">0</span>, j = <span class="number">0</span>, k = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> midptr = nums.size() / <span class="number">2</span> + nums.begin();</span><br><span class="line">        nth_element(nums.begin(), midptr, nums.end());</span><br><span class="line">        <span class="keyword">int</span> mid = *midptr;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index(j) &gt; mid) &#123;</span><br><span class="line">                swap(index(i++), index(j++));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index(j) &lt; mid) &#123;</span><br><span class="line">                swap(index(j), index(k--));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摆动排序，就是一会大于，一会小于。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
